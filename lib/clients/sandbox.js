const {
  DelayEncryptionApi,
  MessageSigningApi,
  PrivateBallotApi,
  RandomBeaconApi,
  SatMetricsApi,
} = require('sandbox-sdk');
const crypto = require('crypto');

/**
 * Class for tracking the status of in asynchronous request.
 */
class Request {
  #status = null;
  #result = null;
  #update = null;

  /**
   * Constructs a Request object
   * @param {Function} update - an async function for updating result
   * from the sandbox API
   */
  constructor(update) {
    this.#status = 'SENT';
    this.#update = update;
  }

  /**
   * Update the status of the request from the API provider.
   */
  async _update() {
    if (this.#result) return;
    const t = await this.#update();
    this.#status = t.status;
    this.#result = t.result;
  }

  /**
   * @return {string} the current status of the request.
   */
  async status() {
    await this._update();
    return this.#status;
  }

  /**
   * @return {Object} when the request is ready this method will return the
   *         result of the request. Until then it will return null.
   */
  async result() {
    await this._update();
    return this.#result;
  }
}

class SandboxClient {
  #satMetricsApi = new SatMetricsApi();
  #randomBeaconApi = new RandomBeaconApi();
  #messageSigningApi = new MessageSigningApi();
  #delayEncryptionApi = new DelayEncryptionApi();
  #privateBallotApi = new PrivateBallotApi();
  #cache = {
    version: '0.1.0',
  };

  /**
   * @return {{version: string, timestamp: Number}} the version of the service
   *         running onboard the satellite last reported by the satellite. The
   *         timestamp refers to the time when that last transmission was
   *         received.
   *
   */
  async version() {
    const response = await this.#satMetricsApi.timestampGet();
    return {
      version: this.#cache.version,
      timestamp: response.timestampMs,
    };
  }

  /**
   * @return {{status: string, timestamp: Number}} the operational status last
   *         reported by the satellite and received by any of the ground
   *         stations. The timestamp refers to the time when that last
   *         was received.
   */
  async status() {
    const response = await this.#satMetricsApi.timestampGet();
    return {
      status: 'ok',
      timestamp: response.timestampMs,
    };
  }

  /**
   * @return {Uint8Array} the cryptosat public key used for signing that was
   *         last reported by the satellite. As opposed to other methods in this
   *         client, the timestamp is not reported here as the public key is
   *         expected to change throughout the lifetime of the satellite.
   */
  async getPublicSigningKey() {
    const response = await this.#satMetricsApi.publicKeysGet();
    const publicKeyPem = response.publicKeys[0];
    const pubKey = crypto.createPublicKey(publicKeyPem);
    const pubKeyBuffer = pubKey.export({format: 'der', type: 'spki'}).slice(12);
    if (pubKeyBuffer.length !== 32) {
      throw new TypeError('Expected an Ed25519 public key');
    }
    return pubKeyBuffer;
  }

  /**
   * @return {{timestamp: Number, signature: Buffer}} a timestamp signed by
   *         the satellite's private RSA key. The timestamp is taken from the
   *         last broadcast transmission received by the satellite.
   */
  async getTimestamp() {
    const response = await this.#satMetricsApi.timestampGet();
    return {
      timestamp: response.timestamp,
      signature: Buffer.from(response.signature, 'hex'),
    };
  }

  /**
   * @return {{publicRandom: Buffer, signature: Buffer}} -
   *         random bytes last generated by the satellite along with the
   *         signature using the
   *         satellite's private RSA key demonstrating it was in fact issued
   *         by the satellite.
   */
  async getPublicRandom() {
    const response = await this.#satMetricsApi.publicRandomGet();
    return {
      publicRandom: Buffer.from(response.randomness, 'hex'),
      signature: Buffer.from(response.signature, 'hex'),
    };
  }

  /**
   * Request a signature from the satellite of a given message.
   * @param {string} msg - the message requiring a signature.
   * @return {Request} - a tracking object to followup on the status of the
   *         request. Once ready, the result will include an object with the
   *         signature of the message using the satellite's signing key.
   */
  async sign(msg) {
    const response = await this.#messageSigningApi.signMessagePost(
      {message: msg},
    );
    const update = async () => {
      const res = await this.#messageSigningApi
        .signMessageStatusRequestUuidGetWithHttpInfo(response.requestUuid);

      if (res.response.statusCode === 200) {
        return {
          status: 'READY',
          result: {
            message: res.data.message,
            timestamp: res.data.timestamp,
            signature: Buffer.from(res.data.signature, 'hex'),
          },
        };
      }

      return {
        status: 'SENT',
        result: null,
      };
    };

    return new Request(update);
  }
}

module.exports = SandboxClient;
