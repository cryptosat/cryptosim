const {
  DelayEncryptionApi,
  MessageSigningApi,
  PrivateBallotApi,
  SatMetricsApi,
} = require('../../sandbox-sdk');
const {pem2ab, hex2ab} = require('../binary');
const {encrypt_message} = require('@cryptosat/private-voting');


/**
 * Class for tracking the status of in asynchronous request.
 */
class Request {
  #status = null;
  #result = null;
  #update = null;

  /**
   * Constructs a Request object
   * @param {Function} update - an async function for updating result
   * from the sandbox API
   */
  constructor(update) {
    this.#status = 'SENT';
    this.#update = update;
  }

  /**
   * Update the status of the request from the API provider.
   */
  async _update() {
    if (this.#result) return;
    const t = await this.#update();
    this.#status = t.status;
    this.#result = t.result;
  }

  /**
   * @return {string} the current status of the request.
   */
  async status() {
    await this._update();
    return this.#status;
  }

  /**
   * @return {Object} when the request is ready this method will return the
   *         result of the request. Until then, it will return null.
   */
  async result() {
    await this._update();
    return this.#result;
  }
}

/**
 * Client for interacting the main service running onboard the satellite.
 * The client communicates with the service using Cryptosat sandbox API.
 */
class SandboxClient {
  #satMetricsApi = new SatMetricsApi();
  #messageSigningApi = new MessageSigningApi();
  #delayEncryptionApi = new DelayEncryptionApi();
  #privateBallotApi = new PrivateBallotApi();
  #cache = {
    version: '0.1.0',
  };

  /**
   * @return {{version: string, timestamp: Number}} the version of the service
   *         running onboard the satellite last reported by the satellite. The
   *         timestamp refers to the time when that last transmission was
   *         received.
   *
   */
  async version() {
    const response = await this.#satMetricsApi.timestampGet();
    return {
      version: this.#cache.version,
      timestamp: response.timestamp,
    };
  }

  /**
   * @return {{status: string, timestamp: Number}} the operational status last
   *         reported by the satellite and received by any of the ground
   *         stations. The timestamp refers to the time when that last
   *         was received.
   */
  async status() {
    const response = await this.#satMetricsApi.timestampGet();
    return {
      status: 'ok',
      timestamp: response.timestamp,
    };
  }

  /**
   * @return {Uint8Array} the cryptosat public key used for signing that was
   *         last reported by the satellite. As opposed to other methods in this
   *         client, the timestamp is not reported here as the public key is
   *         expected to change throughout the lifetime of the satellite.
   */
  async getPublicSigningKey() {
    const response = await this.#satMetricsApi.publicKeysGet();
    const publicKeyPem = response.publicKeys[0];
    const pubKey = pem2ab(publicKeyPem).slice(12);
    if (pubKey.length !== 32) {
      throw new TypeError('Expected an Ed25519 public key');
    }
    return pubKey;
  }

  /**
   * @return {{timestamp: Number, signature: Buffer}} a timestamp signed by
   *         the satellite's private RSA key. The timestamp is taken from the
   *         last broadcast transmission received by the satellite.
   */
  async getTimestamp() {
    const response = await this.#satMetricsApi.timestampGet();
    return {
      timestamp: response.timestamp,
      signature: hex2ab(response.signature),
    };
  }

  /**
   * @return {{publicRandom: Buffer, signature: Buffer}} -
   *         random bytes last generated by the satellite along with the
   *         signature using the
   *         satellite's private RSA key demonstrating it was in fact issued
   *         by the satellite.
   */
  async getPublicRandom() {
    const response = await this.#satMetricsApi.publicRandomGet();
    return {
      publicRandom: hex2ab(response.randomness),
      signature: hex2ab(response.signature),
    };
  }

  /**
   * Request a signature from the satellite of a given message.
   * @param {string} msg - the message requiring a signature.
   * @return {Request} - a tracking object to followup on the status of the
   *         request. Once ready, the result will include an object with the
   *         signature of the message using the satellite's signing key.
   */
  async sign(msg) {
    const response = await this.#messageSigningApi.signMessagePost(
      {message: msg},
    );
    const update = async () => {
      const res = await this.#messageSigningApi
        .signMessageStatusRequestUuidGetWithHttpInfo(response.requestUuid);

      if (res.response.statusCode === 200) {
        return {
          status: 'READY',
          result: {
            message: res.data.message,
            timestamp: res.data.timestamp,
            signature: hex2ab(res.data.signature),
          },
        };
      }

      return {
        status: 'SENT',
        result: null,
      };
    };

    return new Request(update);
  }

  /**
   * Calculates when is the next time the satellite will be online
   * @return {Date} the date of the next transmission window or null if no
   *        transmission window is found within the next deadline.
   */
  nextOnlineTime() {
    return Date.now();
  }

  /**
   * Generates a delayed keypair
   * @param {Date} timeToRelease time to release private key in seconds
   */
  async createDelayedKeypair(timeToRelease) {
    const response = await this.#delayEncryptionApi
      .delayEncKeypairDelayPost(timeToRelease + 's');

    const update = async () => {
      const res = await this.#delayEncryptionApi
        .delayEncKeypairsKeypairIdPublicGetWithHttpInfo(response.keypairId);

      if (res.response.statusCode === 200) {
        const publicKeyPem = res.data.publicKey;
        const pubKey = pem2ab(publicKeyPem);
        return {
          status: 'READY',
          result: {
            keypair_id: response.keypairId,
            public_key: pubKey,
          },
        };
      }

      return {
        status: 'SENT',
        result: null,
      };
    };

    return new Request(update);
  }

  /**
   * Fetches a delayed keypair public key
   * @param {string} keypairId unique keypair ID
   */
  async fetchDelayedPubKey(keypairId) {
    const update = async () => {
      const res = await this.#delayEncryptionApi
        .delayEncKeypairsKeypairIdPublicGetWithHttpInfo(keypairId);

      if (res.response.statusCode === 200) {
        const publicKeyPem = res.data.publicKey;
        const pubKey = pem2ab(publicKeyPem);
        return {
          status: 'READY',
          result: pubKey,
        };
      }

      return {
        status: 'SENT',
        result: null,
      };
    };

    const request = new Request(update);
    await request._update();

    return request;
  }

  /**
   * Fetches a delayed keypair private key
   * @param {string} keypairId unique keypair ID
   */
  async fetchDelayedPrivKey(keypairId) {
    const update = async () => {
      const res = await this.#delayEncryptionApi
        .delayEncKeypairsKeypairIdPrivateGetWithHttpInfo(keypairId);

      if (res.response.statusCode === 200) {
        const privateKeyPem = res.data.privateKey;
        const privKey = pem2ab(privateKeyPem);
        return {
          status: 'READY',
          result: privKey,
        };
      }

      return {
        status: 'SENT',
        result: null,
      };
    };

    const request = new Request(update);
    await request._update();

    return request;
  }

  ballot = {
    init: async (k) => {
      const response =
        await this.#privateBallotApi.ballotMinParticipantsPost(k);

      this.#cache.ballotId = response.ballotId;
      const update = async () => {
        const res = await this.#privateBallotApi
          .ballotsBallotIdGetWithHttpInfo(response.ballotId);

        if (res.response.statusCode === 200) {
          return {
            status: 'READY',
            result: {
              ballot_id: response.ballotId,
              public_key: res.data.publicKey,
            },
          };
        }

        return {
          status: 'SENT',
          result: null,
        };
      };

      return new Request(update);
    },

    vote: async (encryptedVote) => {
      const body = {
        encrypted_vote: encryptedVote,
      };
      await this.#privateBallotApi.ballotsBallotIdVotePost(
        body,
        this.#cache.ballotId,
      );
    },

    finalize: async () => {
      await this.#privateBallotApi.ballotsBallotIdFinalizePost(
        this.#cache.ballotId,
      );
      const update = async () => {
        const res = await this.#privateBallotApi
          .ballotsBallotIdResultGetWithHttpInfo(this.#cache.ballotId);

        if (res.response.statusCode === 200) {
          return {
            status: 'READY',
            result: res.data.ballotResult,
          };
        }

        return {
          status: 'SENT',
          result: null,
        };
      };

      return new Request(update);
    },

    encryptMessage: (publicKeyPem, msg) => {
      return encrypt_message(publicKeyPem, msg);
    },
  };
}

module.exports = SandboxClient;
